#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module Type
  BOOLEAN = 0
  INT32 = 1
  INT64 = 2
  INT96 = 3
  FLOAT = 4
  DOUBLE = 5
  BYTE_ARRAY = 6
  FIXED_LEN_BYTE_ARRAY = 7
  VALUE_MAP = {0 => "BOOLEAN", 1 => "INT32", 2 => "INT64", 3 => "INT96", 4 => "FLOAT", 5 => "DOUBLE", 6 => "BYTE_ARRAY", 7 => "FIXED_LEN_BYTE_ARRAY"}
  VALID_VALUES = Set.new([BOOLEAN, INT32, INT64, INT96, FLOAT, DOUBLE, BYTE_ARRAY, FIXED_LEN_BYTE_ARRAY]).freeze
end

module ConvertedType
  # a BYTE_ARRAY actually contains UTF8 encoded chars
  UTF8 = 0
  # a map is converted as an optional field containing a repeated key/value pair
  MAP = 1
  # a key/value pair is converted into a group of two fields
  MAP_KEY_VALUE = 2
  # a list is converted into an optional field containing a repeated field for its
# values
  LIST = 3
  # an enum is converted into a binary field
  ENUM = 4
  # A decimal value.
# 
# This may be used to annotate binary or fixed primitive types. The
# underlying byte array stores the unscaled value encoded as two's
# complement using big-endian byte order (the most significant byte is the
# zeroth element). The value of the decimal is the value * 10^{-scale}.
# 
# This must be accompanied by a (maximum) precision and a scale in the
# SchemaElement. The precision specifies the number of digits in the decimal
# and the scale stores the location of the decimal point. For example 1.23
# would have precision 3 (3 total digits) and scale 2 (the decimal point is
# 2 digits over).
  DECIMAL = 5
  # A Date
# 
# Stored as days since Unix epoch, encoded as the INT32 physical type.
# 
  DATE = 6
  # A time
# 
# The total number of milliseconds since midnight.  The value is stored
# as an INT32 physical type.
  TIME_MILLIS = 7
  # A time.
# 
# The total number of microseconds since midnight.  The value is stored as
# an INT64 physical type.
  TIME_MICROS = 8
  # A date/time combination
# 
# Date and time recorded as milliseconds since the Unix epoch.  Recorded as
# a physical type of INT64.
  TIMESTAMP_MILLIS = 9
  # A date/time combination
# 
# Date and time recorded as microseconds since the Unix epoch.  The value is
# stored as an INT64 physical type.
  TIMESTAMP_MICROS = 10
  # An unsigned integer value.
# 
# The number describes the maximum number of meainful data bits in
# the stored value. 8, 16 and 32 bit values are stored using the
# INT32 physical type.  64 bit values are stored using the INT64
# physical type.
# 
  UINT_8 = 11
  UINT_16 = 12
  UINT_32 = 13
  UINT_64 = 14
  # A signed integer value.
# 
# The number describes the maximum number of meainful data bits in
# the stored value. 8, 16 and 32 bit values are stored using the
# INT32 physical type.  64 bit values are stored using the INT64
# physical type.
# 
  INT_8 = 15
  INT_16 = 16
  INT_32 = 17
  INT_64 = 18
  # An embedded JSON document
# 
# A JSON document embedded within a single UTF8 column.
  JSON = 19
  # An embedded BSON document
# 
# A BSON document embedded within a single BINARY column.
  BSON = 20
  # An interval of time
# 
# This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
# This data is composed of three separate little endian unsigned
# integers.  Each stores a component of a duration of time.  The first
# integer identifies the number of months associated with the duration,
# the second identifies the number of days associated with the duration
# and the third identifies the number of milliseconds associated with
# the provided duration.  This duration of time is independent of any
# particular timezone or date.
  INTERVAL = 21
  VALUE_MAP = {0 => "UTF8", 1 => "MAP", 2 => "MAP_KEY_VALUE", 3 => "LIST", 4 => "ENUM", 5 => "DECIMAL", 6 => "DATE", 7 => "TIME_MILLIS", 8 => "TIME_MICROS", 9 => "TIMESTAMP_MILLIS", 10 => "TIMESTAMP_MICROS", 11 => "UINT_8", 12 => "UINT_16", 13 => "UINT_32", 14 => "UINT_64", 15 => "INT_8", 16 => "INT_16", 17 => "INT_32", 18 => "INT_64", 19 => "JSON", 20 => "BSON", 21 => "INTERVAL"}
  VALID_VALUES = Set.new([UTF8, MAP, MAP_KEY_VALUE, LIST, ENUM, DECIMAL, DATE, TIME_MILLIS, TIME_MICROS, TIMESTAMP_MILLIS, TIMESTAMP_MICROS, UINT_8, UINT_16, UINT_32, UINT_64, INT_8, INT_16, INT_32, INT_64, JSON, BSON, INTERVAL]).freeze
end

module FieldRepetitionType
  # This field is required (can not be null) and each record has exactly 1 value.
  REQUIRED = 0
  # The field is optional (can be null) and each record has 0 or 1 values.
  OPTIONAL = 1
  # The field is repeated and can contain 0 or more values
  REPEATED = 2
  VALUE_MAP = {0 => "REQUIRED", 1 => "OPTIONAL", 2 => "REPEATED"}
  VALID_VALUES = Set.new([REQUIRED, OPTIONAL, REPEATED]).freeze
end

class Encoding
  # Default encoding.
# BOOLEAN - 1 bit per value. 0 is false; 1 is true.
# INT32 - 4 bytes per value.  Stored as little-endian.
# INT64 - 8 bytes per value.  Stored as little-endian.
# FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
# DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
# BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
# FIXED_LEN_BYTE_ARRAY - Just the bytes.
  PLAIN = 0
  # Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
# plain type.
# in a data page use RLE_DICTIONARY instead.
# in a Dictionary page use PLAIN instead
  PLAIN_DICTIONARY = 2
  # Group packed run length encoding. Usable for definition/repetition levels
# encoding and Booleans (on one bit: 0 is false; 1 is true.)
  RLE = 3
  # Bit packed encoding.  This can only be used if the data has a known max
# width.  Usable for definition/repetition levels encoding.
  BIT_PACKED = 4
  # Delta encoding for integers. This can be used for int columns and works best
# on sorted data
  DELTA_BINARY_PACKED = 5
  # Encoding for byte arrays to separate the length values and the data. The lengths
# are encoded using DELTA_BINARY_PACKED
  DELTA_LENGTH_BYTE_ARRAY = 6
  # Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
# Suffixes are stored as delta length byte arrays.
  DELTA_BYTE_ARRAY = 7
  # Dictionary encoding: the ids are encoded using the RLE encoding
  RLE_DICTIONARY = 8
  VALUE_MAP = {0 => "PLAIN", 2 => "PLAIN_DICTIONARY", 3 => "RLE", 4 => "BIT_PACKED", 5 => "DELTA_BINARY_PACKED", 6 => "DELTA_LENGTH_BYTE_ARRAY", 7 => "DELTA_BYTE_ARRAY", 8 => "RLE_DICTIONARY"}
  VALID_VALUES = Set.new([PLAIN, PLAIN_DICTIONARY, RLE, BIT_PACKED, DELTA_BINARY_PACKED, DELTA_LENGTH_BYTE_ARRAY, DELTA_BYTE_ARRAY, RLE_DICTIONARY]).freeze
end

module CompressionCodec
  UNCOMPRESSED = 0
  SNAPPY = 1
  GZIP = 2
  LZO = 3
  BROTLI = 4
  LZ4 = 5
  ZSTD = 6
  VALUE_MAP = {0 => "UNCOMPRESSED", 1 => "SNAPPY", 2 => "GZIP", 3 => "LZO", 4 => "BROTLI", 5 => "LZ4", 6 => "ZSTD"}
  VALID_VALUES = Set.new([UNCOMPRESSED, SNAPPY, GZIP, LZO, BROTLI, LZ4, ZSTD]).freeze
end

module PageType
  DATA_PAGE = 0
  INDEX_PAGE = 1
  DICTIONARY_PAGE = 2
  DATA_PAGE_V2 = 3
  VALUE_MAP = {0 => "DATA_PAGE", 1 => "INDEX_PAGE", 2 => "DICTIONARY_PAGE", 3 => "DATA_PAGE_V2"}
  VALID_VALUES = Set.new([DATA_PAGE, INDEX_PAGE, DICTIONARY_PAGE, DATA_PAGE_V2]).freeze
end

module BoundaryOrder
  UNORDERED = 0
  ASCENDING = 1
  DESCENDING = 2
  VALUE_MAP = {0 => "UNORDERED", 1 => "ASCENDING", 2 => "DESCENDING"}
  VALID_VALUES = Set.new([UNORDERED, ASCENDING, DESCENDING]).freeze
end

# Statistics per row group and per page
# All fields are optional.
class Statistics
  include ::Thrift::Struct, ::Thrift::Struct_Union
  MAX = 1
  MIN = 2
  NULL_COUNT = 3
  DISTINCT_COUNT = 4
  MAX_VALUE = 5
  MIN_VALUE = 6

  FIELDS = {
    # DEPRECATED: min and max value of the column. Use min_value and max_value.
# 
# Values are encoded using PLAIN encoding, except that variable-length byte
# arrays do not include a length prefix.
# 
# These fields encode min and max values determined by signed comparison
# only. New files should use the correct order for a column's logical type
# and store the values in the min_value and max_value fields.
# 
# To support older readers, these may be set when the column order is
# signed.
    MAX => {:type => ::Thrift::Types::STRING, :name => 'max', :binary => true, :optional => true},
    MIN => {:type => ::Thrift::Types::STRING, :name => 'min', :binary => true, :optional => true},
    # count of null value in the column
    NULL_COUNT => {:type => ::Thrift::Types::I64, :name => 'null_count', :optional => true},
    # count of distinct values occurring
    DISTINCT_COUNT => {:type => ::Thrift::Types::I64, :name => 'distinct_count', :optional => true},
    # Min and max values for the column, determined by its ColumnOrder.
# 
# Values are encoded using PLAIN encoding, except that variable-length byte
# arrays do not include a length prefix.
    MAX_VALUE => {:type => ::Thrift::Types::STRING, :name => 'max_value', :binary => true, :optional => true},
    MIN_VALUE => {:type => ::Thrift::Types::STRING, :name => 'min_value', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# Empty structs to use as logical type annotations
class StringType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class UUIDType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class MapType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class ListType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class EnumType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class DateType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# Logical type to annotate a column that is always null.
# 
# Sometimes when discovering the schema of existing data, values are always
# null and the physical type can't be determined. This annotation signals
# the case where the physical type was guessed from all null values.
class NullType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# Decimal logical type annotation
# 
# To maintain forward-compatibility in v1, implementations using this logical
# type must also set scale and precision on the annotated SchemaElement.
# 
# Allowed for physical types: INT32, INT64, FIXED, and BINARY
class DecimalType
  include ::Thrift::Struct, ::Thrift::Struct_Union
  SCALE = 1
  PRECISION = 2

  FIELDS = {
    SCALE => {:type => ::Thrift::Types::I32, :name => 'scale'},
    PRECISION => {:type => ::Thrift::Types::I32, :name => 'precision'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field scale is unset!') unless @scale
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field precision is unset!') unless @precision
  end

  ::Thrift::Struct.generate_accessors self
end

# Time units for logical types
class MilliSeconds
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class MicroSeconds
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class NanoSeconds
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class TimeUnit < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def MILLIS(val)
      TimeUnit.new(:MILLIS, val)
    end

    def MICROS(val)
      TimeUnit.new(:MICROS, val)
    end

    def NANOS(val)
      TimeUnit.new(:NANOS, val)
    end
  end

  MILLIS = 1
  MICROS = 2
  NANOS = 3

  FIELDS = {
    MILLIS => {:type => ::Thrift::Types::STRUCT, :name => 'MILLIS', :class => ::MilliSeconds},
    MICROS => {:type => ::Thrift::Types::STRUCT, :name => 'MICROS', :class => ::MicroSeconds},
    NANOS => {:type => ::Thrift::Types::STRUCT, :name => 'NANOS', :class => ::NanoSeconds}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

# Timestamp logical type annotation
# 
# Allowed for physical types: INT64
class TimestampType
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ISADJUSTEDTOUTC = 1
  UNIT = 2

  FIELDS = {
    ISADJUSTEDTOUTC => {:type => ::Thrift::Types::BOOL, :name => 'isAdjustedToUTC'},
    UNIT => {:type => ::Thrift::Types::STRUCT, :name => 'unit', :class => ::TimeUnit}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isAdjustedToUTC is unset!') if @isAdjustedToUTC.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unit is unset!') unless @unit
  end

  ::Thrift::Struct.generate_accessors self
end

# Time logical type annotation
# 
# Allowed for physical types: INT32 (millis), INT64 (micros, nanos)
class TimeType
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ISADJUSTEDTOUTC = 1
  UNIT = 2

  FIELDS = {
    ISADJUSTEDTOUTC => {:type => ::Thrift::Types::BOOL, :name => 'isAdjustedToUTC'},
    UNIT => {:type => ::Thrift::Types::STRUCT, :name => 'unit', :class => ::TimeUnit}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isAdjustedToUTC is unset!') if @isAdjustedToUTC.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field unit is unset!') unless @unit
  end

  ::Thrift::Struct.generate_accessors self
end

# Integer logical type annotation
# 
# bitWidth must be 8, 16, 32, or 64.
# 
# Allowed for physical types: INT32, INT64
class IntType
  include ::Thrift::Struct, ::Thrift::Struct_Union
  BITWIDTH = 1
  ISSIGNED = 2

  FIELDS = {
    BITWIDTH => {:type => ::Thrift::Types::BYTE, :name => 'bitWidth'},
    ISSIGNED => {:type => ::Thrift::Types::BOOL, :name => 'isSigned'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bitWidth is unset!') unless @bitWidth
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field isSigned is unset!') if @isSigned.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

# Embedded JSON logical type annotation
# 
# Allowed for physical types: BINARY
class JsonType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# Embedded BSON logical type annotation
# 
# Allowed for physical types: BINARY
class BsonType
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# LogicalType annotations to replace ConvertedType.
# 
# To maintain compatibility, implementations using LogicalType for a
# SchemaElement must also set the corresponding ConvertedType from the
# following table.
class LogicalType < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def STRING(val)
      LogicalType.new(:STRING, val)
    end

    def MAP(val)
      LogicalType.new(:MAP, val)
    end

    def LIST(val)
      LogicalType.new(:LIST, val)
    end

    def ENUM(val)
      LogicalType.new(:ENUM, val)
    end

    def DECIMAL(val)
      LogicalType.new(:DECIMAL, val)
    end

    def DATE(val)
      LogicalType.new(:DATE, val)
    end

    def TIME(val)
      LogicalType.new(:TIME, val)
    end

    def TIMESTAMP(val)
      LogicalType.new(:TIMESTAMP, val)
    end

    def INTEGER(val)
      LogicalType.new(:INTEGER, val)
    end

    def UNKNOWN(val)
      LogicalType.new(:UNKNOWN, val)
    end

    def JSON(val)
      LogicalType.new(:JSON, val)
    end

    def BSON(val)
      LogicalType.new(:BSON, val)
    end

    def UUID(val)
      LogicalType.new(:UUID, val)
    end
  end

  STRING = 1
  MAP = 2
  LIST = 3
  ENUM = 4
  DECIMAL = 5
  DATE = 6
  TIME = 7
  TIMESTAMP = 8
  INTEGER = 10
  UNKNOWN = 11
  JSON = 12
  BSON = 13
  UUID = 14

  FIELDS = {
    STRING => {:type => ::Thrift::Types::STRUCT, :name => 'STRING', :class => ::StringType},
    MAP => {:type => ::Thrift::Types::STRUCT, :name => 'MAP', :class => ::MapType},
    LIST => {:type => ::Thrift::Types::STRUCT, :name => 'LIST', :class => ::ListType},
    ENUM => {:type => ::Thrift::Types::STRUCT, :name => 'ENUM', :class => ::EnumType},
    DECIMAL => {:type => ::Thrift::Types::STRUCT, :name => 'DECIMAL', :class => ::DecimalType},
    DATE => {:type => ::Thrift::Types::STRUCT, :name => 'DATE', :class => ::DateType},
    TIME => {:type => ::Thrift::Types::STRUCT, :name => 'TIME', :class => ::TimeType},
    TIMESTAMP => {:type => ::Thrift::Types::STRUCT, :name => 'TIMESTAMP', :class => ::TimestampType},
    INTEGER => {:type => ::Thrift::Types::STRUCT, :name => 'INTEGER', :class => ::IntType},
    UNKNOWN => {:type => ::Thrift::Types::STRUCT, :name => 'UNKNOWN', :class => ::NullType},
    JSON => {:type => ::Thrift::Types::STRUCT, :name => 'JSON', :class => ::JsonType},
    BSON => {:type => ::Thrift::Types::STRUCT, :name => 'BSON', :class => ::BsonType},
    UUID => {:type => ::Thrift::Types::STRUCT, :name => 'UUID', :class => ::UUIDType}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

# Represents a element inside a schema definition.
#  - if it is a group (inner node) then type is undefined and num_children is defined
#  - if it is a primitive type (leaf) then type is defined and num_children is undefined
# the nodes are listed in depth first traversal order.
class SchemaElement
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  TYPE_LENGTH = 2
  REPETITION_TYPE = 3
  NAME = 4
  NUM_CHILDREN = 5
  CONVERTED_TYPE = 6
  SCALE = 7
  PRECISION = 8
  FIELD_ID = 9
  LOGICALTYPE = 10

  FIELDS = {
    # Data type for this field. Not set if the current element is a non-leaf node
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :optional => true, :enum_class => ::Type},
    # If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the vales.
# Otherwise, if specified, this is the maximum bit length to store any of the values.
# (e.g. a low cardinality INT col could have this set to 3).  Note that this is
# in the schema, and therefore fixed for the entire file.
    TYPE_LENGTH => {:type => ::Thrift::Types::I32, :name => 'type_length', :optional => true},
    # repetition of the field. The root of the schema does not have a repetition_type.
# All other nodes must have one
    REPETITION_TYPE => {:type => ::Thrift::Types::I32, :name => 'repetition_type', :optional => true, :enum_class => ::FieldRepetitionType},
    # Name of the field in the schema
    NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
    # Nested fields.  Since thrift does not support nested fields,
# the nesting is flattened to a single list by a depth-first traversal.
# The children count is used to construct the nested relationship.
# This field is not set when the element is a primitive type
    NUM_CHILDREN => {:type => ::Thrift::Types::I32, :name => 'num_children', :optional => true},
    # When the schema is the result of a conversion from another model
# Used to record the original type to help with cross conversion.
    CONVERTED_TYPE => {:type => ::Thrift::Types::I32, :name => 'converted_type', :optional => true, :enum_class => ::ConvertedType},
    # Used when this column contains decimal data.
# See the DECIMAL converted type for more details.
    SCALE => {:type => ::Thrift::Types::I32, :name => 'scale', :optional => true},
    PRECISION => {:type => ::Thrift::Types::I32, :name => 'precision', :optional => true},
    # When the original schema supports field ids, this will save the
# original field id in the parquet schema
    FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id', :optional => true},
    # The logical type of this SchemaElement
# 
# LogicalType replaces ConvertedType, but ConvertedType is still required
# for some logical types to ensure forward-compatibility in format v1.
    LOGICALTYPE => {:type => ::Thrift::Types::STRUCT, :name => 'logicalType', :class => ::LogicalType, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
    unless @type.nil? || ::Type::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
    unless @repetition_type.nil? || ::FieldRepetitionType::VALID_VALUES.include?(@repetition_type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field repetition_type!')
    end
    unless @converted_type.nil? || ::ConvertedType::VALID_VALUES.include?(@converted_type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field converted_type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# Data page header
class DataPageHeader
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NUM_VALUES = 1
  ENCODING = 2
  DEFINITION_LEVEL_ENCODING = 3
  REPETITION_LEVEL_ENCODING = 4
  STATISTICS = 5

  FIELDS = {
    # Number of values, including NULLs, in this data page. *
    NUM_VALUES => {:type => ::Thrift::Types::I32, :name => 'num_values'},
    # Encoding used for this data page *
    ENCODING => {:type => ::Thrift::Types::I32, :name => 'encoding', :enum_class => ::Encoding},
    # Encoding used for definition levels *
    DEFINITION_LEVEL_ENCODING => {:type => ::Thrift::Types::I32, :name => 'definition_level_encoding', :enum_class => ::Encoding},
    # Encoding used for repetition levels *
    REPETITION_LEVEL_ENCODING => {:type => ::Thrift::Types::I32, :name => 'repetition_level_encoding', :enum_class => ::Encoding},
    # Optional statistics for the data in this page*
    STATISTICS => {:type => ::Thrift::Types::STRUCT, :name => 'statistics', :class => ::Statistics, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_values is unset!') unless @num_values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encoding is unset!') unless @encoding
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field definition_level_encoding is unset!') unless @definition_level_encoding
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field repetition_level_encoding is unset!') unless @repetition_level_encoding
    unless @encoding.nil? || ::Encoding::VALID_VALUES.include?(@encoding)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoding!')
    end
    unless @definition_level_encoding.nil? || ::Encoding::VALID_VALUES.include?(@definition_level_encoding)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field definition_level_encoding!')
    end
    unless @repetition_level_encoding.nil? || ::Encoding::VALID_VALUES.include?(@repetition_level_encoding)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field repetition_level_encoding!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class IndexPageHeader
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# TODO: *
class DictionaryPageHeader
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NUM_VALUES = 1
  ENCODING = 2
  IS_SORTED = 3

  FIELDS = {
    # Number of values in the dictionary *
    NUM_VALUES => {:type => ::Thrift::Types::I32, :name => 'num_values'},
    # Encoding using this dictionary page *
    ENCODING => {:type => ::Thrift::Types::I32, :name => 'encoding', :enum_class => ::Encoding},
    # If true, the entries in the dictionary are sorted in ascending order *
    IS_SORTED => {:type => ::Thrift::Types::BOOL, :name => 'is_sorted', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_values is unset!') unless @num_values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encoding is unset!') unless @encoding
    unless @encoding.nil? || ::Encoding::VALID_VALUES.include?(@encoding)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoding!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# New page format allowing reading levels without decompressing the data
# Repetition and definition levels are uncompressed
# The remaining section containing the data is compressed if is_compressed is true
# 
class DataPageHeaderV2
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NUM_VALUES = 1
  NUM_NULLS = 2
  NUM_ROWS = 3
  ENCODING = 4
  DEFINITION_LEVELS_BYTE_LENGTH = 5
  REPETITION_LEVELS_BYTE_LENGTH = 6
  IS_COMPRESSED = 7
  STATISTICS = 8

  FIELDS = {
    # Number of values, including NULLs, in this data page. *
    NUM_VALUES => {:type => ::Thrift::Types::I32, :name => 'num_values'},
    # Number of NULL values, in this data page.
# Number of non-null = num_values - num_nulls which is also the number of values in the data section *
    NUM_NULLS => {:type => ::Thrift::Types::I32, :name => 'num_nulls'},
    # Number of rows in this data page. which means pages change on record boundaries (r = 0) *
    NUM_ROWS => {:type => ::Thrift::Types::I32, :name => 'num_rows'},
    # Encoding used for data in this page *
    ENCODING => {:type => ::Thrift::Types::I32, :name => 'encoding', :enum_class => ::Encoding},
    # length of the definition levels
    DEFINITION_LEVELS_BYTE_LENGTH => {:type => ::Thrift::Types::I32, :name => 'definition_levels_byte_length'},
    # length of the repetition levels
    REPETITION_LEVELS_BYTE_LENGTH => {:type => ::Thrift::Types::I32, :name => 'repetition_levels_byte_length'},
    # whether the values are compressed.
# Which means the section of the page between
# definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
# is compressed with the compression_codec.
# If missing it is considered compressed
    IS_COMPRESSED => {:type => ::Thrift::Types::BOOL, :name => 'is_compressed', :default => true, :optional => true},
    # optional statistics for this column chunk
    STATISTICS => {:type => ::Thrift::Types::STRUCT, :name => 'statistics', :class => ::Statistics, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_values is unset!') unless @num_values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_nulls is unset!') unless @num_nulls
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_rows is unset!') unless @num_rows
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encoding is unset!') unless @encoding
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field definition_levels_byte_length is unset!') unless @definition_levels_byte_length
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field repetition_levels_byte_length is unset!') unless @repetition_levels_byte_length
    unless @encoding.nil? || ::Encoding::VALID_VALUES.include?(@encoding)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoding!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class PageHeader
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  UNCOMPRESSED_PAGE_SIZE = 2
  COMPRESSED_PAGE_SIZE = 3
  CRC = 4
  DATA_PAGE_HEADER = 5
  INDEX_PAGE_HEADER = 6
  DICTIONARY_PAGE_HEADER = 7
  DATA_PAGE_HEADER_V2 = 8

  FIELDS = {
    # the type of the page: indicates which of the *_header fields is set *
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::PageType},
    # Uncompressed page size in bytes (not including this header) *
    UNCOMPRESSED_PAGE_SIZE => {:type => ::Thrift::Types::I32, :name => 'uncompressed_page_size'},
    # Compressed page size in bytes (not including this header) *
    COMPRESSED_PAGE_SIZE => {:type => ::Thrift::Types::I32, :name => 'compressed_page_size'},
    # 32bit crc for the data below. This allows for disabling checksumming in HDFS
# if only a few pages needs to be read
# 
    CRC => {:type => ::Thrift::Types::I32, :name => 'crc', :optional => true},
    DATA_PAGE_HEADER => {:type => ::Thrift::Types::STRUCT, :name => 'data_page_header', :class => ::DataPageHeader, :optional => true},
    INDEX_PAGE_HEADER => {:type => ::Thrift::Types::STRUCT, :name => 'index_page_header', :class => ::IndexPageHeader, :optional => true},
    DICTIONARY_PAGE_HEADER => {:type => ::Thrift::Types::STRUCT, :name => 'dictionary_page_header', :class => ::DictionaryPageHeader, :optional => true},
    DATA_PAGE_HEADER_V2 => {:type => ::Thrift::Types::STRUCT, :name => 'data_page_header_v2', :class => ::DataPageHeaderV2, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uncompressed_page_size is unset!') unless @uncompressed_page_size
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field compressed_page_size is unset!') unless @compressed_page_size
    unless @type.nil? || ::PageType::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# Wrapper struct to store key values
class KeyValue
  include ::Thrift::Struct, ::Thrift::Struct_Union
  KEY = 1
  VALUE = 2

  FIELDS = {
    KEY => {:type => ::Thrift::Types::STRING, :name => 'key'},
    VALUE => {:type => ::Thrift::Types::STRING, :name => 'value', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field key is unset!') unless @key
  end

  ::Thrift::Struct.generate_accessors self
end

# Wrapper struct to specify sort order
class SortingColumn
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLUMN_IDX = 1
  DESCENDING = 2
  NULLS_FIRST = 3

  FIELDS = {
    # The column index (in this row group) *
    COLUMN_IDX => {:type => ::Thrift::Types::I32, :name => 'column_idx'},
    # If true, indicates this column is sorted in descending order. *
    DESCENDING => {:type => ::Thrift::Types::BOOL, :name => 'descending'},
    # If true, nulls will come before non-null values, otherwise,
# nulls go at the end.
    NULLS_FIRST => {:type => ::Thrift::Types::BOOL, :name => 'nulls_first'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field column_idx is unset!') unless @column_idx
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field descending is unset!') if @descending.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nulls_first is unset!') if @nulls_first.nil?
  end

  ::Thrift::Struct.generate_accessors self
end

# statistics of a given page type and encoding
class PageEncodingStats
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PAGE_TYPE = 1
  ENCODING = 2
  COUNT = 3

  FIELDS = {
    # the page type (data/dic/...) *
    PAGE_TYPE => {:type => ::Thrift::Types::I32, :name => 'page_type', :enum_class => ::PageType},
    # encoding of the page *
    ENCODING => {:type => ::Thrift::Types::I32, :name => 'encoding', :enum_class => ::Encoding},
    # number of pages of this type with this encoding *
    COUNT => {:type => ::Thrift::Types::I32, :name => 'count'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field page_type is unset!') unless @page_type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encoding is unset!') unless @encoding
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field count is unset!') unless @count
    unless @page_type.nil? || ::PageType::VALID_VALUES.include?(@page_type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field page_type!')
    end
    unless @encoding.nil? || ::Encoding::VALID_VALUES.include?(@encoding)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoding!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# Description for column metadata
class ColumnMetaData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  TYPE = 1
  ENCODINGS = 2
  PATH_IN_SCHEMA = 3
  CODEC = 4
  NUM_VALUES = 5
  TOTAL_UNCOMPRESSED_SIZE = 6
  TOTAL_COMPRESSED_SIZE = 7
  KEY_VALUE_METADATA = 8
  DATA_PAGE_OFFSET = 9
  INDEX_PAGE_OFFSET = 10
  DICTIONARY_PAGE_OFFSET = 11
  STATISTICS = 12
  ENCODING_STATS = 13

  FIELDS = {
    # Type of this column *
    TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::Type},
    # Set of all encodings used for this column. The purpose is to validate
# whether we can decode those pages. *
    ENCODINGS => {:type => ::Thrift::Types::LIST, :name => 'encodings', :element => {:type => ::Thrift::Types::I32, :enum_class => ::Encoding}},
    # Path in schema *
    PATH_IN_SCHEMA => {:type => ::Thrift::Types::LIST, :name => 'path_in_schema', :element => {:type => ::Thrift::Types::STRING}},
    # Compression codec *
    CODEC => {:type => ::Thrift::Types::I32, :name => 'codec', :enum_class => ::CompressionCodec},
    # Number of values in this column *
    NUM_VALUES => {:type => ::Thrift::Types::I64, :name => 'num_values'},
    # total byte size of all uncompressed pages in this column chunk (including the headers) *
    TOTAL_UNCOMPRESSED_SIZE => {:type => ::Thrift::Types::I64, :name => 'total_uncompressed_size'},
    # total byte size of all compressed pages in this column chunk (including the headers) *
    TOTAL_COMPRESSED_SIZE => {:type => ::Thrift::Types::I64, :name => 'total_compressed_size'},
    # Optional key/value metadata *
    KEY_VALUE_METADATA => {:type => ::Thrift::Types::LIST, :name => 'key_value_metadata', :element => {:type => ::Thrift::Types::STRUCT, :class => ::KeyValue}, :optional => true},
    # Byte offset from beginning of file to first data page *
    DATA_PAGE_OFFSET => {:type => ::Thrift::Types::I64, :name => 'data_page_offset'},
    # Byte offset from beginning of file to root index page *
    INDEX_PAGE_OFFSET => {:type => ::Thrift::Types::I64, :name => 'index_page_offset', :optional => true},
    # Byte offset from the beginning of file to first (only) dictionary page *
    DICTIONARY_PAGE_OFFSET => {:type => ::Thrift::Types::I64, :name => 'dictionary_page_offset', :optional => true},
    # optional statistics for this column chunk
    STATISTICS => {:type => ::Thrift::Types::STRUCT, :name => 'statistics', :class => ::Statistics, :optional => true},
    # Set of all encodings used for pages in this column chunk.
# This information can be used to determine if all data pages are
# dictionary encoded for example *
    ENCODING_STATS => {:type => ::Thrift::Types::LIST, :name => 'encoding_stats', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PageEncodingStats}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field type is unset!') unless @type
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encodings is unset!') unless @encodings
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field path_in_schema is unset!') unless @path_in_schema
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field codec is unset!') unless @codec
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_values is unset!') unless @num_values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field total_uncompressed_size is unset!') unless @total_uncompressed_size
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field total_compressed_size is unset!') unless @total_compressed_size
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field data_page_offset is unset!') unless @data_page_offset
    unless @type.nil? || ::Type::VALID_VALUES.include?(@type)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
    end
    unless @codec.nil? || ::CompressionCodec::VALID_VALUES.include?(@codec)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field codec!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

class EncryptionWithFooterKey
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class EncryptionWithColumnKey
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PATH_IN_SCHEMA = 1
  COLUMN_KEY_METADATA = 2

  FIELDS = {
    # Column path in schema *
    PATH_IN_SCHEMA => {:type => ::Thrift::Types::LIST, :name => 'path_in_schema', :element => {:type => ::Thrift::Types::STRING}},
    # Retrieval metadata of the column-specific key *
    COLUMN_KEY_METADATA => {:type => ::Thrift::Types::STRING, :name => 'column_key_metadata', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field path_in_schema is unset!') unless @path_in_schema
  end

  ::Thrift::Struct.generate_accessors self
end

class ColumnCryptoMetaData < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def ENCRYPTION_WITH_FOOTER_KEY(val)
      ColumnCryptoMetaData.new(:ENCRYPTION_WITH_FOOTER_KEY, val)
    end

    def ENCRYPTION_WITH_COLUMN_KEY(val)
      ColumnCryptoMetaData.new(:ENCRYPTION_WITH_COLUMN_KEY, val)
    end
  end

  ENCRYPTION_WITH_FOOTER_KEY = 1
  ENCRYPTION_WITH_COLUMN_KEY = 2

  FIELDS = {
    ENCRYPTION_WITH_FOOTER_KEY => {:type => ::Thrift::Types::STRUCT, :name => 'ENCRYPTION_WITH_FOOTER_KEY', :class => ::EncryptionWithFooterKey},
    ENCRYPTION_WITH_COLUMN_KEY => {:type => ::Thrift::Types::STRUCT, :name => 'ENCRYPTION_WITH_COLUMN_KEY', :class => ::EncryptionWithColumnKey}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class ColumnChunk
  include ::Thrift::Struct, ::Thrift::Struct_Union
  FILE_PATH = 1
  FILE_OFFSET = 2
  META_DATA = 3
  OFFSET_INDEX_OFFSET = 4
  OFFSET_INDEX_LENGTH = 5
  COLUMN_INDEX_OFFSET = 6
  COLUMN_INDEX_LENGTH = 7
  CRYPTO_META_DATA = 8

  FIELDS = {
    # File where column data is stored.  If not set, assumed to be same file as
# metadata.  This path is relative to the current file.
# 
    FILE_PATH => {:type => ::Thrift::Types::STRING, :name => 'file_path', :optional => true},
    # Byte offset in file_path to the ColumnMetaData *
    FILE_OFFSET => {:type => ::Thrift::Types::I64, :name => 'file_offset'},
    # Column metadata for this chunk. This is the same content as what is at
# file_path/file_offset.  Having it here has it replicated in the file
# metadata.
# 
    META_DATA => {:type => ::Thrift::Types::STRUCT, :name => 'meta_data', :class => ::ColumnMetaData, :optional => true},
    # File offset of ColumnChunk's OffsetIndex *
    OFFSET_INDEX_OFFSET => {:type => ::Thrift::Types::I64, :name => 'offset_index_offset', :optional => true},
    # Size of ColumnChunk's OffsetIndex, in bytes *
    OFFSET_INDEX_LENGTH => {:type => ::Thrift::Types::I32, :name => 'offset_index_length', :optional => true},
    # File offset of ColumnChunk's ColumnIndex *
    COLUMN_INDEX_OFFSET => {:type => ::Thrift::Types::I64, :name => 'column_index_offset', :optional => true},
    # Size of ColumnChunk's ColumnIndex, in bytes *
    COLUMN_INDEX_LENGTH => {:type => ::Thrift::Types::I32, :name => 'column_index_length', :optional => true},
    # Crypto metadata of encrypted columns *
    CRYPTO_META_DATA => {:type => ::Thrift::Types::STRUCT, :name => 'crypto_meta_data', :class => ::ColumnCryptoMetaData, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field file_offset is unset!') unless @file_offset
  end

  ::Thrift::Struct.generate_accessors self
end

class RowGroup
  include ::Thrift::Struct, ::Thrift::Struct_Union
  COLUMNS = 1
  TOTAL_BYTE_SIZE = 2
  NUM_ROWS = 3
  SORTING_COLUMNS = 4
  FILE_OFFSET = 5
  TOTAL_COMPRESSED_SIZE = 6

  FIELDS = {
    # Metadata for each column chunk in this row group.
# This list must have the same order as the SchemaElement list in FileMetaData.
# 
    COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ColumnChunk}},
    # Total byte size of all the uncompressed column data in this row group *
    TOTAL_BYTE_SIZE => {:type => ::Thrift::Types::I64, :name => 'total_byte_size'},
    # Number of rows in this row group *
    NUM_ROWS => {:type => ::Thrift::Types::I64, :name => 'num_rows'},
    # If set, specifies a sort ordering of the rows in this RowGroup.
# The sorting columns can be a subset of all the columns.
    SORTING_COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'sorting_columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SortingColumn}, :optional => true},
    # Byte offset from beginning of file to first page (data or dictionary)
# in this row group *
    FILE_OFFSET => {:type => ::Thrift::Types::I64, :name => 'file_offset', :optional => true},
    # Total byte size of all compressed column data in this row group *
    TOTAL_COMPRESSED_SIZE => {:type => ::Thrift::Types::I64, :name => 'total_compressed_size', :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field columns is unset!') unless @columns
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field total_byte_size is unset!') unless @total_byte_size
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_rows is unset!') unless @num_rows
  end

  ::Thrift::Struct.generate_accessors self
end

# Empty struct to signal the order defined by the physical or logical type
class TypeDefinedOrder
  include ::Thrift::Struct, ::Thrift::Struct_Union

  FIELDS = {

  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

# Union to specify the order used for the min_value and max_value fields for a
# column. This union takes the role of an enhanced enum that allows rich
# elements (which will be needed for a collation-based ordering in the future).
# 
# Possible values are:
# * TypeDefinedOrder - the column uses the order defined by its logical or
#                      physical type (if there is no logical type).
# 
# If the reader does not support the value of this union, min and max stats
# for this column should be ignored.
class ColumnOrder < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def TYPE_ORDER(val)
      ColumnOrder.new(:TYPE_ORDER, val)
    end
  end

  TYPE_ORDER = 1

  FIELDS = {
    # The sort orders for logical types are:
#   UTF8 - unsigned byte-wise comparison
#   INT8 - signed comparison
#   INT16 - signed comparison
#   INT32 - signed comparison
#   INT64 - signed comparison
#   UINT8 - unsigned comparison
#   UINT16 - unsigned comparison
#   UINT32 - unsigned comparison
#   UINT64 - unsigned comparison
#   DECIMAL - signed comparison of the represented value
#   DATE - signed comparison
#   TIME_MILLIS - signed comparison
#   TIME_MICROS - signed comparison
#   TIMESTAMP_MILLIS - signed comparison
#   TIMESTAMP_MICROS - signed comparison
#   INTERVAL - unsigned comparison
#   JSON - unsigned byte-wise comparison
#   BSON - unsigned byte-wise comparison
#   ENUM - unsigned byte-wise comparison
#   LIST - undefined
#   MAP - undefined
# 
# In the absence of logical types, the sort order is determined by the physical type:
#   BOOLEAN - false, true
#   INT32 - signed comparison
#   INT64 - signed comparison
#   INT96 (only used for legacy timestamps) - undefined
#   FLOAT - signed comparison of the represented value (*)
#   DOUBLE - signed comparison of the represented value (*)
#   BYTE_ARRAY - unsigned byte-wise comparison
#   FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison
# 
# (*) Because the sorting order is not specified properly for floating
#     point values (relations vs. total ordering) the following
#     compatibility rules should be applied when reading statistics:
#     - If the min is a NaN, it should be ignored.
#     - If the max is a NaN, it should be ignored.
#     - If the min is +0, the row group may contain -0 values as well.
#     - If the max is -0, the row group may contain +0 values as well.
#     - When looking for NaN values, min and max should be ignored.
    TYPE_ORDER => {:type => ::Thrift::Types::STRUCT, :name => 'TYPE_ORDER', :class => ::TypeDefinedOrder}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class PageLocation
  include ::Thrift::Struct, ::Thrift::Struct_Union
  OFFSET = 1
  COMPRESSED_PAGE_SIZE = 2
  FIRST_ROW_INDEX = 3

  FIELDS = {
    # Offset of the page in the file *
    OFFSET => {:type => ::Thrift::Types::I64, :name => 'offset'},
    # Size of the page, including header. Sum of compressed_page_size and header
# length
    COMPRESSED_PAGE_SIZE => {:type => ::Thrift::Types::I32, :name => 'compressed_page_size'},
    # Index within the RowGroup of the first row of the page; this means pages
# change on record boundaries (r = 0).
    FIRST_ROW_INDEX => {:type => ::Thrift::Types::I64, :name => 'first_row_index'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field offset is unset!') unless @offset
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field compressed_page_size is unset!') unless @compressed_page_size
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field first_row_index is unset!') unless @first_row_index
  end

  ::Thrift::Struct.generate_accessors self
end

class OffsetIndex
  include ::Thrift::Struct, ::Thrift::Struct_Union
  PAGE_LOCATIONS = 1

  FIELDS = {
    # PageLocations, ordered by increasing PageLocation.offset. It is required
# that page_locations[i].first_row_index < page_locations[i+1].first_row_index.
    PAGE_LOCATIONS => {:type => ::Thrift::Types::LIST, :name => 'page_locations', :element => {:type => ::Thrift::Types::STRUCT, :class => ::PageLocation}}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field page_locations is unset!') unless @page_locations
  end

  ::Thrift::Struct.generate_accessors self
end

# Description for ColumnIndex.
# Each <array-field>[i] refers to the page at OffsetIndex.page_locations[i]
class ColumnIndex
  include ::Thrift::Struct, ::Thrift::Struct_Union
  NULL_PAGES = 1
  MIN_VALUES = 2
  MAX_VALUES = 3
  BOUNDARY_ORDER = 4
  NULL_COUNTS = 5

  FIELDS = {
    # A list of Boolean values to determine the validity of the corresponding
# min and max values. If true, a page contains only null values, and writers
# have to set the corresponding entries in min_values and max_values to
# byte[0], so that all lists have the same length. If false, the
# corresponding entries in min_values and max_values must be valid.
    NULL_PAGES => {:type => ::Thrift::Types::LIST, :name => 'null_pages', :element => {:type => ::Thrift::Types::BOOL}},
    # Two lists containing lower and upper bounds for the values of each page.
# These may be the actual minimum and maximum values found on a page, but
# can also be (more compact) values that do not exist on a page. For
# example, instead of storing ""Blart Versenwald III", a writer may set
# min_values[i]="B", max_values[i]="C". Such more compact values must still
# be valid values within the column's logical type. Readers must make sure
# that list entries are populated before using them by inspecting null_pages.
    MIN_VALUES => {:type => ::Thrift::Types::LIST, :name => 'min_values', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
    MAX_VALUES => {:type => ::Thrift::Types::LIST, :name => 'max_values', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
    # Stores whether both min_values and max_values are orderd and if so, in
# which direction. This allows readers to perform binary searches in both
# lists. Readers cannot assume that max_values[i] <= min_values[i+1], even
# if the lists are ordered.
    BOUNDARY_ORDER => {:type => ::Thrift::Types::I32, :name => 'boundary_order', :enum_class => ::BoundaryOrder},
    # A list containing the number of null values for each page *
    NULL_COUNTS => {:type => ::Thrift::Types::LIST, :name => 'null_counts', :element => {:type => ::Thrift::Types::I64}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field null_pages is unset!') unless @null_pages
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field min_values is unset!') unless @min_values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field max_values is unset!') unless @max_values
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field boundary_order is unset!') unless @boundary_order
    unless @boundary_order.nil? || ::BoundaryOrder::VALID_VALUES.include?(@boundary_order)
      raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field boundary_order!')
    end
  end

  ::Thrift::Struct.generate_accessors self
end

# Description for file metadata
class FileMetaData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  VERSION = 1
  SCHEMA = 2
  NUM_ROWS = 3
  ROW_GROUPS = 4
  KEY_VALUE_METADATA = 5
  CREATED_BY = 6
  COLUMN_ORDERS = 7

  FIELDS = {
    # Version of this file *
    VERSION => {:type => ::Thrift::Types::I32, :name => 'version'},
    # Parquet schema for this file.  This schema contains metadata for all the columns.
# The schema is represented as a tree with a single root.  The nodes of the tree
# are flattened to a list by doing a depth-first traversal.
# The column metadata contains the path in the schema for that column which can be
# used to map columns to nodes in the schema.
# The first element is the root *
    SCHEMA => {:type => ::Thrift::Types::LIST, :name => 'schema', :element => {:type => ::Thrift::Types::STRUCT, :class => ::SchemaElement}},
    # Number of rows in this file *
    NUM_ROWS => {:type => ::Thrift::Types::I64, :name => 'num_rows'},
    # Row groups in this file *
    ROW_GROUPS => {:type => ::Thrift::Types::LIST, :name => 'row_groups', :element => {:type => ::Thrift::Types::STRUCT, :class => ::RowGroup}},
    # Optional key/value metadata *
    KEY_VALUE_METADATA => {:type => ::Thrift::Types::LIST, :name => 'key_value_metadata', :element => {:type => ::Thrift::Types::STRUCT, :class => ::KeyValue}, :optional => true},
    # String for application that wrote this file.  This should be in the format
# <Application> version <App Version> (build <App Build Hash>).
# e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)
# 
    CREATED_BY => {:type => ::Thrift::Types::STRING, :name => 'created_by', :optional => true},
    # Sort order used for the min_value and max_value fields of each column in
# this file. Each sort order corresponds to one column, determined by its
# position in the list, matching the position of the column in the schema.
# 
# Without column_orders, the meaning of the min_value and max_value fields is
# undefined. To ensure well-defined behaviour, if min_value and max_value are
# written to a Parquet file, column_orders must be written as well.
# 
# The obsolete min and max fields are always sorted by signed comparison
# regardless of column_orders.
    COLUMN_ORDERS => {:type => ::Thrift::Types::LIST, :name => 'column_orders', :element => {:type => ::Thrift::Types::STRUCT, :class => ::ColumnOrder}, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field version is unset!') unless @version
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field schema is unset!') unless @schema
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_rows is unset!') unless @num_rows
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field row_groups is unset!') unless @row_groups
  end

  ::Thrift::Struct.generate_accessors self
end

class AesGcmV1
  include ::Thrift::Struct, ::Thrift::Struct_Union
  AAD_METADATA = 1
  IV_PREFIX = 2

  FIELDS = {
    # Retrieval metadata of AAD used for encryption of pages and structures *
    AAD_METADATA => {:type => ::Thrift::Types::STRING, :name => 'aad_metadata', :binary => true, :optional => true},
    # If file IVs are comprised of a fixed part, and variable parts
# (e.g. counter), keep the fixed part here *
    IV_PREFIX => {:type => ::Thrift::Types::STRING, :name => 'iv_prefix', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class AesGcmCtrV1
  include ::Thrift::Struct, ::Thrift::Struct_Union
  AAD_METADATA = 1
  GCM_IV_PREFIX = 2
  CTR_IV_PREFIX = 3

  FIELDS = {
    # Retrieval metadata of AAD used for encryption of structures *
    AAD_METADATA => {:type => ::Thrift::Types::STRING, :name => 'aad_metadata', :binary => true, :optional => true},
    # If file IVs are comprised of a fixed part, and variable parts
# (e.g. counter), keep the fixed part here *
    GCM_IV_PREFIX => {:type => ::Thrift::Types::STRING, :name => 'gcm_iv_prefix', :binary => true, :optional => true},
    CTR_IV_PREFIX => {:type => ::Thrift::Types::STRING, :name => 'ctr_iv_prefix', :binary => true, :optional => true}
  }

  def struct_fields; FIELDS; end

  def validate
  end

  ::Thrift::Struct.generate_accessors self
end

class EncryptionAlgorithm < ::Thrift::Union
  include ::Thrift::Struct_Union
  class << self
    def AES_GCM_V1(val)
      EncryptionAlgorithm.new(:AES_GCM_V1, val)
    end

    def AES_GCM_CTR_V1(val)
      EncryptionAlgorithm.new(:AES_GCM_CTR_V1, val)
    end
  end

  AES_GCM_V1 = 1
  AES_GCM_CTR_V1 = 2

  FIELDS = {
    AES_GCM_V1 => {:type => ::Thrift::Types::STRUCT, :name => 'AES_GCM_V1', :class => ::AesGcmV1},
    AES_GCM_CTR_V1 => {:type => ::Thrift::Types::STRUCT, :name => 'AES_GCM_CTR_V1', :class => ::AesGcmCtrV1}
  }

  def struct_fields; FIELDS; end

  def validate
    raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
  end

  ::Thrift::Union.generate_accessors self
end

class FileCryptoMetaData
  include ::Thrift::Struct, ::Thrift::Struct_Union
  ENCRYPTION_ALGORITHM = 1
  ENCRYPTED_FOOTER = 2
  FOOTER_KEY_METADATA = 3
  FOOTER_OFFSET = 4

  FIELDS = {
    ENCRYPTION_ALGORITHM => {:type => ::Thrift::Types::STRUCT, :name => 'encryption_algorithm', :class => ::EncryptionAlgorithm},
    # Parquet footer can be encrypted, or left as plaintext *
    ENCRYPTED_FOOTER => {:type => ::Thrift::Types::BOOL, :name => 'encrypted_footer'},
    # Retrieval metadata of key used for encryption of footer,
# and (possibly) columns *
    FOOTER_KEY_METADATA => {:type => ::Thrift::Types::STRING, :name => 'footer_key_metadata', :binary => true, :optional => true},
    # Offset of Parquet footer (encrypted, or plaintext) *
    FOOTER_OFFSET => {:type => ::Thrift::Types::I64, :name => 'footer_offset'}
  }

  def struct_fields; FIELDS; end

  def validate
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encryption_algorithm is unset!') unless @encryption_algorithm
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field encrypted_footer is unset!') if @encrypted_footer.nil?
    raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field footer_offset is unset!') unless @footer_offset
  end

  ::Thrift::Struct.generate_accessors self
end

